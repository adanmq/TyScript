public void simulationStart()
{
}

public void simulationStep()
{
    float lowerScaleLimit = GetFloat("LowerScaleLimit");
    float upperScaleLimit = GetFloat("UpperScaleLimit");
    
    for (int i = 0; i < eventParticleCount; i++)
    {
        int sInx = tf.GetSimIndex(i);
        tf.SetCustomFloat(sInx, "customID", -1);
    }

    List<Tuple<float, int>> particleScales = new List<Tuple<float, int>>();

    for (int i = 0; i < eventParticleCount; i++)
    {
        int sInx = tf.GetSimIndex(i);
        Point3 scale = tf.GetScale(sInx);
        float magnitude = scale.magnitude;

        if ((magnitude >= lowerScaleLimit) && (upperScaleLimit == 0 || magnitude <= upperScaleLimit))
        {
            particleScales.Add(new Tuple<float, int>(magnitude, sInx));
        }
    }

    particleScales.Sort((a, b) => b.Item1.CompareTo(a.Item1));

    float startID = GetFloat("StartID");
    float numTargets = GetFloat("NumTargets");

    int particlesPerTarget = eventParticleCount / (int)numTargets;
    int remainder = eventParticleCount % (int)numTargets;

    int counter = 0;
    for (int i = 0; i < particleScales.Count; i++)
    {
        int sInx = particleScales[i].Item2;
        
        float customID;
        if (counter < remainder)
        {
            customID = startID + (float)(i / (particlesPerTarget + 1));
            if (i % (particlesPerTarget + 1) == 0 && i != 0)
                counter++;
        }
        else
        {
            customID = startID + (float)((i - counter) / particlesPerTarget);
        }
        
        tf.SetCustomFloat(sInx, "customID", customID);
    }
}

public void simulationStepThreaded(int startInx, int endInx, int threadInx)					
{
}
